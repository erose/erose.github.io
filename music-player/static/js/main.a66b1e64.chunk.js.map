{"version":3,"sources":["spinner.ico","audio-visualizer.jsx","Audio.jsx","SongList.jsx","App.jsx","index.jsx"],"names":["module","exports","AudioVisualizer","audioElement","this","audioContext","AudioContext","lowPassFilter","createBiquadFilter","type","highPassFilter","lowFreqAnalyser","createAnalyser","fftSize","highFreqAnalyser","source","createMediaElementSource","connect","destination","bufferLength","frequencyBinCount","lowFreqDataArray","Uint8Array","highFreqDataArray","getByteTimeDomainData","lowFreqMax","Math","max","x","min","exp","highFreqMax","y","z","Audio","props","onAudioElementRefAvailable","visualizer","currentAnimationId","requestAnimationFrame","draw","document","body","style","backgroundColor","getColor","state","loadingStatus","isPlaying","canvas","React","createRef","currentIntervalId","clearInterval","stopVisualization","filenameClassName","className","onClick","onPausePressed","role","src","spinner","alt","aria-label","autoPlay","crossOrigin","onCanPlay","onLoadingFinished","url","filename","ref","onEnded","onPlayPressed","setState","cancelAnimationFrame","Component","SongList","handleOnPopState","event","searchString","doSearch","handleKeyDown","key","ctrlKeyDepressed","handleKeyUp","renderFile","currentlyPlaying","includes","s3Url","encodeURIComponent","startPlaying","stopPlaying","visibleFiles","filenames","searchBoxRef","window","addEventListener","removeEventListener","currentTimeoutId","clearTimeout","prevProps","_prevState","_snapshot","_","isEqual","loadingIndicator","placeholder","autoFocus","value","spellCheck","onFocus","target","select","onChange","onSearchTermChanged","onNewClicked","marginTop","map","current","string","setTimeout","saveSearchString","downcasedSearchString","toLowerCase","filtered","filter","urlParams","URLSearchParams","location","search","set","history","pushState","origin","pathname","toString","nextUpSongIndex","indexOf","newCurrentlyPlaying","f","length","nextSong","push","setDocumentTitle","concat","toDisplay","last","split","title","a","keys","continuationToken","paramString","fetch","response","text","xml","newkeys","$","find","toArray","node","textContent","App","getKeysInS3Bucket","then","get","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.a66b1e64.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/spinner.2f27f045.ico\";","export default class AudioVisualizer {\n  constructor(audioElement) {\n    this.audioContext = new AudioContext();\n\n    // TODO: Explain.\n    this.lowPassFilter = this.audioContext.createBiquadFilter();\n    this.lowPassFilter.type = 'lowpass';\n    this.highPassFilter = this.audioContext.createBiquadFilter();\n    this.highPassFilter.type = \"highpass\";\n    this.lowFreqAnalyser = this.audioContext.createAnalyser();\n    this.lowFreqAnalyser.fftSize = 2048;\n    this.highFreqAnalyser = this.audioContext.createAnalyser();\n    this.highFreqAnalyser.fftSize = 2048;\n\n    this.source = this.audioContext.createMediaElementSource(audioElement);\n    this.source.connect(this.lowPassFilter);\n    this.source.connect(this.highPassFilter);\n\n    this.lowPassFilter.connect(this.lowFreqAnalyser);\n    this.highPassFilter.connect(this.highFreqAnalyser);\n    this.source.connect(this.audioContext.destination);\n  }\n\n  // Returns a string suitable to be used as the value for CSS 'background-color' or 'color'\n  // attributes.\n  getColor() {\n    // TODO: Explain.\n    const bufferLength = this.lowFreqAnalyser.frequencyBinCount;\n    const lowFreqDataArray = new Uint8Array(bufferLength);\n    const highFreqDataArray = new Uint8Array(bufferLength);\n    this.lowFreqAnalyser.getByteTimeDomainData(lowFreqDataArray);\n    this.highFreqAnalyser.getByteTimeDomainData(highFreqDataArray);\n\n    const lowFreqMax = Math.max(...lowFreqDataArray);\n    const x = 128 + Math.min(Math.exp((lowFreqMax - 128) / 10.0), 128);\n    const highFreqMax = Math.max(...highFreqDataArray);\n    const y = 128 + Math.min(Math.exp((highFreqMax - 128) / 10.0), 128);\n    const z = (x + y) / 2;\n\n    return `rgb(${x}, ${y}, ${z})`;\n  }\n}\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport _ from 'lodash';\n\nimport './Audio.scss';\nimport spinner from './spinner.ico';\n\nimport AudioVisualizer from './audio-visualizer';\n\n// Enum.\nconst loading = 'loading';\nconst loaded = 'loaded';\n\nclass Audio extends React.Component {\n  static propTypes = {\n    url: PropTypes.string.isRequired,\n    isPlaying: PropTypes.bool.isRequired,\n    filename: PropTypes.string.isRequired,\n\n    onPlayPressed: PropTypes.func.isRequired,\n    onPausePressed: PropTypes.func.isRequired,\n    onEnded: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      loadingStatus: props.isPlaying ? loading : null,\n    }\n\n    this.audioElement = null; // TODO explain\n    this.canvas = React.createRef(); // TODO explain\n    this.currentAnimationId = null; // TODO explain\n  }\n\n  componentWillUnmount() {\n    // Cancel any getDataFromAnalyser calls that may be waiting to run.\n    if (this.currentIntervalId) {\n      clearInterval(this.currentIntervalId);\n    }\n\n    this.stopVisualization();\n  }\n\n  render() {\n    const filenameClassName = this.props.isPlaying ? 'filename playing' : 'filename';\n\n    if (!this.props.isPlaying) {\n      return (\n        <div className='Audio' onClick={() => this.onPlayPressed()}>\n          <div className='icon-container play-pause' role=\"button\">\n            <span role=\"img\" className='play-symbol' aria-label=\"Play\">></span>\n          </div>\n\n          <div className={filenameClassName}>\n            {this.props.filename}\n          </div>\n        </div>\n      );\n    }\n\n    if (this.state.loadingStatus === loading) {\n      // The point of this <audio> element is just to load the file. It will actually be played by\n      // the <audio> element that is rendered in the other case of this function.\n      return (\n        <div className='Audio' onClick={() => this.onPausePressed()}>\n          <div className='icon-container loading-spinner' role=\"button\">\n            <img role=\"img\" src={spinner} className='spinner' alt='' aria-label=\"Play\"></img>\n\n            <audio autoPlay={true} crossOrigin='anonymous' onCanPlay={() => this.onLoadingFinished()}>\n              <source src={this.props.url}/>\n            </audio>\n          </div>\n\n          <div className={filenameClassName}>\n            {this.props.filename}\n          </div>\n        </div>\n      );\n    }\n\n    if (this.state.loadingStatus === loaded) {\n      return (\n        <div className='Audio' onClick={() => this.onPausePressed()}>\n          <div className='icon-container play-pause' role=\"button\">\n            <span role=\"img\" className='pause-symbol' aria-label=\"Pause\">|  |</span>\n            \n            <audio ref={this.onAudioElementRefAvailable} crossOrigin='anonymous' autoPlay={true} onEnded={() => this.props.onEnded()}>\n              <source src={this.props.url}/>\n            </audio>\n          </div>\n\n          <div className={filenameClassName}>\n            {this.props.filename}\n          </div>\n        </div>\n      );\n    }\n  }\n\n  onAudioElementRefAvailable = (audioElement) => {\n    if (audioElement !== null) {\n      this.visualizer = new AudioVisualizer(audioElement);\n      this.currentAnimationId = requestAnimationFrame(this.draw);\n    }\n  }\n\n  draw = () => {\n    // Retrieve the color appropriate to this moment in the song, and set it.\n    document.body.style.backgroundColor = this.visualizer.getColor();\n\n    this.currentAnimationId = requestAnimationFrame(this.draw);\n  }\n\n  onPlayPressed() {\n    this.props.onPlayPressed();\n  }\n\n  onLoadingFinished() {\n    this.setState({ loadingStatus: loaded });\n  }\n\n  onPausePressed() {\n    this.stopVisualization();\n    this.props.onPausePressed();\n  }\n\n  stopVisualization() {\n    document.body.style.backgroundColor = '';\n    cancelAnimationFrame(this.currentAnimationId);\n    this.currentAnimationId = null;\n  }\n}\n\nexport default Audio;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport _ from 'lodash';\n\nimport './SongList.scss';\n\nimport Audio from './Audio';\n\nclass SongList extends React.Component {\n  static propTypes = {\n    filenames: PropTypes.arrayOf(PropTypes.string.isRequired), // may be null if we haven't loaded the data yet.\n    s3Url: PropTypes.string.isRequired,\n\n    searchString: PropTypes.string, // Optional; what to initialize the searchString prop to.\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      // These pieces of state are for the search feature. The main challenge is that searching\n      // through all filenames is expensive, so we don't want to do it on every keystroke. Instead\n      // we want to do it when the user pauses typing. So while they're in the middle of typing,\n      // we'll have some text in the input box that we haven't actually done a search with yet. We\n      // need to represent this intermediate state, so we need to store 1) 'searchString', the thing\n      // to be searched, separately from 2) 'visibleFiles', the result of the search.\n      visibleFiles: props.filenames === null ? null : [],\n      searchString: props.searchString || '',\n      \n      currentlyPlaying: [], // a list of filename strings (many songs can be playing at once).\n      ctrlKeyDepressed: false, // some extra behavior is enabled when this is true.\n    };\n\n    // We maintain a ref to the search box so we can have buttons that focus on it.\n    this.searchBoxRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // Allows use of the 'back' button to go between searches.\n    window.addEventListener('popstate', this.handleOnPopState);\n\n    // Allows us to track whether the ctrl key is pressed.\n    window.addEventListener('keydown', this.handleKeyDown);\n    window.addEventListener('keyup', this.handleKeyUp);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('popstate', this.handleOnPopState);\n    window.removeEventListener('keydown', this.handleKeyDown);\n    window.removeEventListener('keyup', this.handleKeyUp);\n\n    // Cancel any doSearches that may be waiting to run.\n    if (this.currentTimeoutId) {\n      clearTimeout(this.currentTimeoutId);\n    }\n  }\n\n  handleOnPopState = (event) => {\n    let searchString = '';\n    if (event.state) {\n      searchString = event.state.searchString;\n    }\n\n    this.setState({ searchString, });\n    this.doSearch(searchString);\n  }\n\n  handleKeyDown = (event) => {\n    if (event.key === 'Control') {\n      this.setState({ ctrlKeyDepressed: true });\n    }\n  }\n\n  handleKeyUp = (event) => {\n    if (event.key === 'Control') {\n      this.setState({ ctrlKeyDepressed: false }); \n    }\n  }\n\n  // If the available filenames change, we need to redo our search. \n  componentDidUpdate(prevProps, _prevState, _snapshot) {\n    if (_.isEqual(this.props.filenames, prevProps.filenames)) {\n      return;\n    }\n\n    this.doSearch(this.state.searchString);\n  }\n\n  render() {\n    const visibleFiles = this.state.visibleFiles;\n    const loadingIndicator = <span>Loading...</span>; // TODO: Make it cool.\n\n    return (\n      <div className='SongList'>\n        <div>\n          <input\n            placeholder=\"Search...\"\n            autoFocus={true}\n            value={this.state.searchString}\n            role={'searchbox'}\n            spellCheck=\"false\"\n            ref={this.searchBoxRef}\n            onFocus={(event) => event.target.select()}\n            onChange={(event) => this.onSearchTermChanged(event.target.value)}\n          />\n\n          <button onClick={() => this.onNewClicked()}>\n            New Search\n          </button>\n        </div>\n\n        <div style={{marginTop: '1rem'}}>\n          {(visibleFiles && visibleFiles.map(this.renderFile)) || loadingIndicator}\n        </div>\n      </div>\n    );\n  }\n\n  onNewClicked() {\n    this.searchBoxRef.current.select();\n  }\n\n  renderFile = (filename) => {\n    const isPlaying = this.state.currentlyPlaying.includes(filename);\n    // 'key' is necessary because we want to create a new component when the song is played, rather\n    // than updating the existing component instance. We want to do this because we need to reset\n    // state. See\n    // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key\n    // .\n    const key = `${filename}-${isPlaying}`;\n    const url = this.props.s3Url + encodeURIComponent(filename);\n\n    return (\n      <div className='file-container' key={filename}>\n        <Audio\n          url={url}\n          isPlaying={isPlaying}\n          key={key}\n          filename={filename}\n\n          onPlayPressed={() => this.startPlaying(filename)}\n          onPausePressed={() => this.stopPlaying(filename)}\n          onEnded={() => this.onEnded(filename)}\n        />\n      </div>\n    );\n  }\n\n  onSearchTermChanged(string) {\n    this.setState({ searchString: string });\n\n    // Stop the previous search, if any, from happening; this new one supersedes it.\n    if (this.currentTimeoutId) {\n      clearTimeout(this.currentTimeoutId);\n    }\n\n    const delay = 750; // ms\n    this.currentTimeoutId = setTimeout(() => {\n      this.doSearch(string);\n      this.saveSearchString(string);\n    }, delay);\n  }\n\n  // Update 'visibleFiles.'\n  doSearch(searchString) {\n    const downcasedSearchString = searchString.toLowerCase();\n    // Display no files on an empty search.\n    if (downcasedSearchString === '') {\n      this.setState({ visibleFiles: [] });\n      return;\n    }\n    \n    const filtered = this.props.filenames.filter(\n      (filename) => filename.toLowerCase().includes(downcasedSearchString)\n    );\n    this.setState({ visibleFiles: filtered });\n  }\n\n  // Marks this search string as a 'checkpoint', saving it in the URL and enabling us to use the\n  // back button to come back to it later.\n  saveSearchString(string) {\n    const urlParams = new URLSearchParams(window.location.search);\n    urlParams.set('search', string);\n    \n    // See https://developer.mozilla.org/en-US/docs/Web/API/History/pushState . In particular: most\n    // browsers ignore the second argument so we pass the empty string.\n    window.history.pushState(\n      { searchString: string },\n      '',\n      window.location.origin + window.location.pathname + '?' + urlParams.toString()\n    );\n  }\n\n  onEnded(filename) {\n    const justEndedSongIndex = this.state.visibleFiles.indexOf(filename);\n    const nextUpSongIndex = justEndedSongIndex + 1;\n\n    let newCurrentlyPlaying = this.state.currentlyPlaying;\n    newCurrentlyPlaying = newCurrentlyPlaying.filter((f) => f !== filename); // stop this song\n\n    if (nextUpSongIndex < this.state.visibleFiles.length) {\n      const nextSong = this.state.visibleFiles[nextUpSongIndex];\n      newCurrentlyPlaying.push(nextSong);\n    } else {\n      // If we're at the end, do nothing.\n    }\n\n    this.setState({ currentlyPlaying: newCurrentlyPlaying }, () => this.setDocumentTitle());\n  }\n\n  startPlaying(filename) {\n    // We allow the user to play multiple songs at the same time if they hold down the control key\n    // when clicking on a new song to be played.\n    let newCurrentlyPlaying;\n    if (this.state.ctrlKeyDepressed) {\n      newCurrentlyPlaying = this.state.currentlyPlaying.concat([filename]);\n    } else {\n      newCurrentlyPlaying = [filename];\n    }\n\n    this.setState({ currentlyPlaying: newCurrentlyPlaying }, () => this.setDocumentTitle());\n  }\n\n  stopPlaying(filename) {\n    this.setState(\n      { currentlyPlaying: this.state.currentlyPlaying.filter((f) => f !== filename) },\n      () => this.setDocumentTitle()\n    );\n  }\n\n  setDocumentTitle() {\n    const filename = this.state.currentlyPlaying[0];\n    // We just want to show the base part of the filename — not the artist or album.\n    const toDisplay = filename && _.last(filename.split('/'));\n\n    if (toDisplay) {\n      document.title = `🎶 — ${toDisplay}`;\n    } else {\n      document.title = `🎶`;\n    }\n  }\n}\n\nexport default SongList;\n","import React from 'react';\nimport $ from 'jquery'; // We use jQuery just in this file to parse XML.\n\nimport SongList from './SongList';\n\n// Globals.\nconst s3Url = 'https://elis-music.s3.us-east-2.amazonaws.com/';\n\nasync function getKeysInS3Bucket() {\n  const keys = [];\n  let continuationToken = null;\n\n  while (true) {\n    let paramString = 'list-type=2';\n    if (continuationToken) {\n      paramString += `&continuation-token=${encodeURIComponent(continuationToken)}`\n    }\n    const response = await fetch(s3Url + '?' + paramString);\n    const xml = await response.text();\n    const newkeys = $(xml).find(\"Contents > Key\").toArray().map((node) => node.textContent);\n    keys.push(...newkeys);\n\n    if ($(xml).find(\"IsTruncated\").text() !== 'true') { break; }\n    continuationToken = $(xml).find(\"NextContinuationToken\").text();\n  }\n  return keys;\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      keys: null, // list of strings; the keys we've loaded from S3. null if we haven't loaded them yet.\n    };\n  }\n\n  componentDidMount() {\n    getKeysInS3Bucket().then((keys) => this.setState({ keys }));\n  }\n\n  render() {\n    // Try to extract searchString from queryparams; if it's not present, the result will be null.\n    const searchString = (new URLSearchParams(window.location.search)).get('search');\n    \n    return (\n      <SongList filenames={this.state.keys} s3Url={s3Url} searchString={searchString}/>\n    )\n  }  \n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport App from './App.jsx';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}