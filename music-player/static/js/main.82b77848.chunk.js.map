{"version":3,"sources":["spinner.ico","Audio.jsx","SongList.jsx","App.jsx","index.jsx"],"names":["module","exports","Audio","props","state","loadingStatus","isPlaying","this","className","role","src","spinner","alt","aria-label","autoPlay","onCanPlay","onLoadingFinished","url","onClick","onPausePressed","onEnded","onPlayPressed","setState","React","Component","SongList","handleOnPopState","event","searchString","doSearch","renderFile","filename","currentlyPlaying","includes","key","s3Url","startPlaying","stopPlaying","visibleFiles","filenames","window","addEventListener","removeEventListener","currentTimeoutId","clearTimeout","prevProps","_prevState","_snapshot","_","isEqual","loadingIndicator","placeholder","autoFocus","value","onChange","onSearchTermChanged","target","style","marginTop","map","string","setTimeout","saveSearchString","downcasedSearchString","toLowerCase","filtered","filter","urlParams","URLSearchParams","location","search","set","history","pushState","origin","pathname","toString","nextUpSongIndex","indexOf","newCurrentlyPlaying","f","length","nextSong","push","concat","a","keys","continuationToken","paramString","encodeURIComponent","fetch","response","text","xml","newkeys","$","find","toArray","node","textContent","App","getKeysInS3Bucket","then","get","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.82b77848.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/spinner.2f27f045.ico\";","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport './Audio.scss';\nimport spinner from './spinner.ico';\n\n// Enum.\nconst loading = 'loading';\nconst loaded = 'loaded';\n\nclass Audio extends React.Component {\n  static propTypes = {\n    url: PropTypes.string.isRequired,\n    isPlaying: PropTypes.bool.isRequired,\n\n    onPlayPressed: PropTypes.func.isRequired,\n    onPausePressed: PropTypes.func.isRequired,\n    onEnded: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      loadingStatus: props.isPlaying ? loading : null,\n    }\n  }\n\n  render() {\n    if (!this.props.isPlaying) {\n      return (\n        <div className='Audio'>\n          <div className='play-pause-symbol-container' role=\"button\" onClick={() => this.onPlayPressed()}>\n            <span role=\"img\" className='play-symbol' aria-label=\"Play\">▶️</span>\n          </div>\n        </div>\n      );\n    }\n\n    if (this.state.loadingStatus === loading) {\n      // The point of this <audio> element is just to load the file. It will actually be played by\n      // the <audio> element that is rendered in the other case of this function.\n      return (\n        <div className='Audio'>\n          <div className='loading-spinner-container' role=\"button\">\n            <img role=\"img\" src={spinner} className='spinner' alt='' aria-label=\"Play\"></img>\n\n            <audio autoPlay={true} onCanPlay={() => this.onLoadingFinished()}>\n              <source src={this.props.url}/>\n            </audio>\n          </div>\n        </div>\n      );\n    }\n\n    if (this.state.loadingStatus === loaded) {\n      return (\n        <div className='Audio'>\n          <div className='play-pause-symbol-container' role=\"button\" onClick={() => this.onPausePressed()}>\n            <span role=\"img\" className='pause-symbol' aria-label=\"Pause\">⏸️</span>\n            \n            <audio autoPlay={true} onEnded={() => this.props.onEnded()}>\n              <source src={this.props.url}/>\n            </audio>\n          </div>\n        </div>\n      );\n    }\n  }\n\n  onPlayPressed() {\n    this.props.onPlayPressed();\n  }\n\n  onLoadingFinished() {\n    this.setState({ loadingStatus: loaded });\n  }\n\n  onPausePressed() {\n    this.props.onPausePressed();\n  }\n}\n\nexport default Audio;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport _ from 'lodash';\n\nimport './SongList.scss';\n\nimport Audio from './Audio';\n\nclass SongList extends React.Component {\n  static propTypes = {\n    filenames: PropTypes.arrayOf(PropTypes.string.isRequired), // may be null if we haven't loaded the data yet.\n    s3Url: PropTypes.string.isRequired,\n\n    searchString: PropTypes.string, // Optional; what to initialize the searchString prop to.\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      // These pieces of state are for the search feature. The main challenge is that searching\n      // through all filenames is expensive, so we don't want to do it on every keystroke. Instead\n      // we want to do it when the user pauses typing. So while they're in the middle of typing,\n      // we'll have some text in the input box that we haven't actually done a search with yet. We\n      // need to represent this intermediate state, so we need to store 1) 'searchString', the thing\n      // to be searched, separately from 2) 'visibleFiles', the result of the search.\n      visibleFiles: props.filenames === null ? null : [],\n      searchString: props.searchString || '',\n      \n      currentlyPlaying: [], // a list of filename strings (many songs can be playing at once).\n    };\n  }\n\n  componentDidMount() {\n    // Allows use of the 'back' button to go between searches.\n    window.addEventListener('popstate', this.handleOnPopState);\n  }\n\n  componentWillUnmount() {\n    // Allows use of the 'back' button to go between searches.\n    window.removeEventListener('popstate', this.handleOnPopState);\n\n    // Cancel any doSearches that may be waiting to run.\n    if (this.currentTimeoutId) {\n      clearTimeout(this.currentTimeoutId);\n    }\n  }\n\n  handleOnPopState = (event) => {\n    let searchString = '';\n    if (event.state) {\n      searchString = event.state.searchString;\n    }\n\n    this.setState({ searchString, });\n    this.doSearch(searchString);\n  }\n\n  // If the available filenames change, we need to redo our search. \n  componentDidUpdate(prevProps, _prevState, _snapshot) {\n    if (_.isEqual(this.props.filenames, prevProps.filenames)) {\n      return;\n    }\n\n    this.doSearch(this.state.searchString);\n  }\n\n  render() {\n    const visibleFiles = this.state.visibleFiles;\n    const loadingIndicator = <span>Loading...</span>; // TODO: Make it cool.\n\n    return (\n      <div className='SongList'>\n        <input\n          placeholder=\"Search...\"\n          autoFocus={true}\n          value={this.state.searchString}\n          role={'searchbox'}\n          onChange={(event) => this.onSearchTermChanged(event.target.value)}\n        />\n\n        <div style={{marginTop: '1rem'}}>\n          {(visibleFiles && visibleFiles.map(this.renderFile)) || loadingIndicator}\n        </div>\n      </div>\n    );\n  }\n\n  renderFile = (filename) => {\n    const isPlaying = this.state.currentlyPlaying.includes(filename);\n    // 'key' is necessary because we want to create a new component when the song is played, rather\n    // than updating the existing component instance. We want to do this because we need to reset\n    // state. See\n    // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key\n    // .\n    const key = `${filename}-${isPlaying}`;\n\n    return (\n      <div className='file-container' key={filename}>\n        <Audio\n          url={this.props.s3Url + filename}\n          isPlaying={isPlaying}\n          key={key}\n\n          onPlayPressed={() => this.startPlaying(filename)}\n          onPausePressed={() => this.stopPlaying(filename)}\n          onEnded={() => this.onEnded(filename)}\n        />\n\n        <span className={isPlaying ? 'filename playing' : 'filename'}>\n          {filename}\n        </span>\n      </div>\n    );\n  }\n\n  onSearchTermChanged(string) {\n    this.setState({ searchString: string });\n\n    // Stop the previous search, if any, from happening; this new one supersedes it.\n    if (this.currentTimeoutId) {\n      clearTimeout(this.currentTimeoutId);\n    }\n\n    const delay = 750; // ms\n    this.currentTimeoutId = setTimeout(() => {\n      this.doSearch(string);\n      this.saveSearchString(string);\n    }, delay);\n  }\n\n  // Update 'visibleFiles.'\n  doSearch(searchString) {\n    const downcasedSearchString = searchString.toLowerCase();\n    // Display no files on an empty search.\n    if (downcasedSearchString === '') {\n      this.setState({ visibleFiles: [] });\n      return;\n    }\n    \n    const filtered = this.props.filenames.filter(\n      (filename) => filename.toLowerCase().includes(downcasedSearchString)\n    );\n    this.setState({ visibleFiles: filtered });\n  }\n\n  // Marks this search string as a 'checkpoint', saving it in the URL and enabling us to use the\n  // back button to come back to it later.\n  saveSearchString(string) {\n    const urlParams = new URLSearchParams(window.location.search);\n    urlParams.set('search', string);\n    \n    // See https://developer.mozilla.org/en-US/docs/Web/API/History/pushState . In particular: most\n    // browsers ignore the second argument so we pass the empty string.\n    window.history.pushState(\n      { searchString: string },\n      '',\n      window.location.origin + window.location.pathname + '?' + urlParams.toString()\n    );\n  }\n\n  onEnded(filename) {\n    const justEndedSongIndex = this.state.visibleFiles.indexOf(filename);\n    const nextUpSongIndex = justEndedSongIndex + 1;\n\n    let newCurrentlyPlaying = this.state.currentlyPlaying;\n    newCurrentlyPlaying = newCurrentlyPlaying.filter((f) => f !== filename); // stop this song\n\n    if (nextUpSongIndex < this.state.visibleFiles.length) {\n      const nextSong = this.state.visibleFiles[nextUpSongIndex];\n      newCurrentlyPlaying.push(nextSong);\n    } else {\n      // If we're at the end, do nothing.\n    }\n\n    this.setState({ currentlyPlaying: newCurrentlyPlaying });\n  }\n\n  startPlaying(filename) {\n    this.setState({ currentlyPlaying: this.state.currentlyPlaying.concat(filename) });\n  }\n\n  stopPlaying(filename) {\n    this.setState({ currentlyPlaying: this.state.currentlyPlaying.filter((f) => f !== filename) });\n  }\n}\n\nexport default SongList;\n","import React from 'react';\nimport $ from 'jquery'; // We use jQuery just in this file to parse XML.\n\nimport SongList from './SongList';\n\n// Globals.\nconst s3Url = 'https://elis-music.s3.us-east-2.amazonaws.com/';\n\nasync function getKeysInS3Bucket() {\n  const keys = [];\n  let continuationToken = null;\n\n  while (true) {\n    let paramString = 'list-type=2';\n    if (continuationToken) {\n      paramString += `&continuation-token=${encodeURIComponent(continuationToken)}`\n    }\n    const response = await fetch(s3Url + '?' + paramString);\n    const xml = await response.text();\n    const newkeys = $(xml).find(\"Contents > Key\").toArray().map((node) => node.textContent);\n    keys.push(...newkeys);\n\n    if ($(xml).find(\"IsTruncated\").text() !== 'true') { break; }\n    continuationToken = $(xml).find(\"NextContinuationToken\").text();\n  }\n  return keys;\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      keys: null, // list of strings; the keys we've loaded from S3. null if we haven't loaded them yet.\n    };\n  }\n\n  componentDidMount() {\n    getKeysInS3Bucket().then((keys) => this.setState({ keys }));\n  }\n\n  render() {\n    // Try to extract searchString from queryparams; if it's not present, the result will be null.\n    const searchString = (new URLSearchParams(window.location.search)).get('search');\n    \n    return (\n      <SongList filenames={this.state.keys} s3Url={s3Url} searchString={searchString}/>\n    )\n  }  \n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport App from './App.jsx';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}