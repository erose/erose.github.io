{"version":3,"sources":["spinner.ico","Audio.jsx","SongList.jsx","App.jsx","index.jsx"],"names":["module","exports","Audio","props","state","loadingStatus","isPlaying","filenameClassName","this","className","onClick","onPausePressed","role","src","spinner","alt","aria-label","autoPlay","onCanPlay","onLoadingFinished","url","filename","onEnded","onPlayPressed","setState","React","Component","SongList","handleOnPopState","event","searchString","doSearch","renderFile","currentlyPlaying","includes","key","s3Url","startPlaying","stopPlaying","visibleFiles","filenames","window","addEventListener","removeEventListener","currentTimeoutId","clearTimeout","prevProps","_prevState","_snapshot","_","isEqual","loadingIndicator","placeholder","autoFocus","value","spellCheck","onFocus","target","select","onChange","onSearchTermChanged","style","marginTop","map","string","setTimeout","saveSearchString","downcasedSearchString","toLowerCase","filtered","filter","urlParams","URLSearchParams","location","search","set","history","pushState","origin","pathname","toString","nextUpSongIndex","indexOf","newCurrentlyPlaying","f","length","nextSong","push","concat","a","keys","continuationToken","paramString","encodeURIComponent","fetch","response","text","xml","newkeys","$","find","toArray","node","textContent","App","getKeysInS3Bucket","then","get","ReactDOM","render","document","getElementById"],"mappings":"sGAAAA,EAAOC,QAAU,IAA0B,qC,yTCkG5BC,E,YA7Eb,WAAYC,GAAQ,IAAD,8BACjB,4CAAMA,KAEDC,MAAQ,CACXC,cAAeF,EAAMG,UAlBX,UAkBiC,MAJ5B,E,sEAQT,IAAD,OACDC,EAAoBC,KAAKL,MAAMG,UAAY,mBAAqB,WAEtE,OAAKE,KAAKL,MAAMG,UAzBJ,YAuCRE,KAAKJ,MAAMC,cAIX,yBAAKI,UAAU,QAAQC,QAAS,kBAAM,EAAKC,mBACzC,yBAAKF,UAAU,4BAA4BG,KAAK,UAC9C,yBAAKA,KAAK,MAAMC,IAAKC,IAASL,UAAU,UAAUM,IAAI,GAAGC,aAAW,SAEpE,2BAAOC,UAAU,EAAMC,UAAW,kBAAM,EAAKC,sBAC3C,4BAAQN,IAAKL,KAAKL,MAAMiB,QAI5B,yBAAKX,UAAWF,GACbC,KAAKL,MAAMkB,WApDT,WA0DPb,KAAKJ,MAAMC,cAEX,yBAAKI,UAAU,QAAQC,QAAS,kBAAM,EAAKC,mBACzC,yBAAKF,UAAU,8BAA8BG,KAAK,UAChD,0BAAMA,KAAK,MAAMH,UAAU,eAAeO,aAAW,SAArD,QAEA,2BAAOC,UAAU,EAAMK,QAAS,kBAAM,EAAKnB,MAAMmB,YAC/C,4BAAQT,IAAKL,KAAKL,MAAMiB,QAI5B,yBAAKX,UAAWF,GACbC,KAAKL,MAAMkB,gBAZpB,EAhCI,yBAAKZ,UAAU,QAAQC,QAAS,kBAAM,EAAKa,kBACzC,yBAAKd,UAAU,8BAA8BG,KAAK,UAChD,0BAAMA,KAAK,MAAMH,UAAU,cAAcO,aAAW,QAApD,MAGF,yBAAKP,UAAWF,GACbC,KAAKL,MAAMkB,a,sCA8CpBb,KAAKL,MAAMoB,kB,0CAIXf,KAAKgB,SAAS,CAAEnB,cAlFL,a,uCAsFXG,KAAKL,MAAMQ,qB,GApFKc,IAAMC,WCgLXC,E,YA1Kb,WAAYxB,GAAQ,IAAD,8BACjB,4CAAMA,KA+BRyB,iBAAmB,SAACC,GAClB,IAAIC,EAAe,GACfD,EAAMzB,QACR0B,EAAeD,EAAMzB,MAAM0B,cAG7B,EAAKN,SAAS,CAAEM,iBAChB,EAAKC,SAASD,IAvCG,EA0EnBE,WAAa,SAACX,GACZ,IAAMf,EAAY,EAAKF,MAAM6B,iBAAiBC,SAASb,GAMjDc,EAAG,UAAMd,EAAN,YAAkBf,GAE3B,OACE,yBAAKG,UAAU,iBAAiB0B,IAAKd,GACnC,kBAAC,EAAD,CACED,IAAK,EAAKjB,MAAMiC,MAAQf,EACxBf,UAAWA,EACX6B,IAAKA,EACLd,SAAUA,EAEVE,cAAe,kBAAM,EAAKc,aAAahB,IACvCV,eAAgB,kBAAM,EAAK2B,YAAYjB,IACvCC,QAAS,kBAAM,EAAKA,QAAQD,QA1FlC,EAAKjB,MAAQ,CAOXmC,aAAkC,OAApBpC,EAAMqC,UAAqB,KAAO,GAChDV,aAAc3B,EAAM2B,cAAgB,GAEpCG,iBAAkB,IAbH,E,iFAmBjBQ,OAAOC,iBAAiB,WAAYlC,KAAKoB,oB,6CAKzCa,OAAOE,oBAAoB,WAAYnC,KAAKoB,kBAGxCpB,KAAKoC,kBACPC,aAAarC,KAAKoC,oB,yCAeHE,EAAWC,EAAYC,GACpCC,IAAEC,QAAQ1C,KAAKL,MAAMqC,UAAWM,EAAUN,YAI9ChC,KAAKuB,SAASvB,KAAKJ,MAAM0B,gB,+BAGjB,IAAD,OACDS,EAAe/B,KAAKJ,MAAMmC,aAC1BY,EAAmB,4CAEzB,OACE,yBAAK1C,UAAU,YACb,2BACE2C,YAAY,YACZC,WAAW,EACXC,MAAO9C,KAAKJ,MAAM0B,aAClBlB,KAAM,YACN2C,WAAW,QACXC,QAAS,SAAC3B,GAAD,OAAWA,EAAM4B,OAAOC,UACjCC,SAAU,SAAC9B,GAAD,OAAW,EAAK+B,oBAAoB/B,EAAM4B,OAAOH,UAG7D,yBAAKO,MAAO,CAACC,UAAW,SACpBvB,GAAgBA,EAAawB,IAAIvD,KAAKwB,aAAgBmB,M,0CA+B5Ca,GAAS,IAAD,OAC1BxD,KAAKgB,SAAS,CAAEM,aAAckC,IAG1BxD,KAAKoC,kBACPC,aAAarC,KAAKoC,kBAIpBpC,KAAKoC,iBAAmBqB,YAAW,WACjC,EAAKlC,SAASiC,GACd,EAAKE,iBAAiBF,KAHV,O,+BAQPlC,GACP,IAAMqC,EAAwBrC,EAAasC,cAE3C,GAA8B,KAA1BD,EAAJ,CAKA,IAAME,EAAW7D,KAAKL,MAAMqC,UAAU8B,QACpC,SAACjD,GAAD,OAAcA,EAAS+C,cAAclC,SAASiC,MAEhD3D,KAAKgB,SAAS,CAAEe,aAAc8B,SAP5B7D,KAAKgB,SAAS,CAAEe,aAAc,O,uCAYjByB,GACf,IAAMO,EAAY,IAAIC,gBAAgB/B,OAAOgC,SAASC,QACtDH,EAAUI,IAAI,SAAUX,GAIxBvB,OAAOmC,QAAQC,UACb,CAAE/C,aAAckC,GAChB,GACAvB,OAAOgC,SAASK,OAASrC,OAAOgC,SAASM,SAAW,IAAMR,EAAUS,c,8BAIhE3D,GACN,IACM4D,EADqBzE,KAAKJ,MAAMmC,aAAa2C,QAAQ7D,GACd,EAEzC8D,EAAsB3E,KAAKJ,MAAM6B,iBAGrC,GAFAkD,EAAsBA,EAAoBb,QAAO,SAACc,GAAD,OAAOA,IAAM/D,KAE1D4D,EAAkBzE,KAAKJ,MAAMmC,aAAa8C,OAAQ,CACpD,IAAMC,EAAW9E,KAAKJ,MAAMmC,aAAa0C,GACzCE,EAAoBI,KAAKD,GAK3B9E,KAAKgB,SAAS,CAAES,iBAAkBkD,M,mCAGvB9D,GACXb,KAAKgB,SAAS,CAAES,iBAAkBzB,KAAKJ,MAAM6B,iBAAiBuD,OAAOnE,O,kCAG3DA,GACVb,KAAKgB,SAAS,CAAES,iBAAkBzB,KAAKJ,MAAM6B,iBAAiBqC,QAAO,SAACc,GAAD,OAAOA,IAAM/D,W,GA9K/DI,IAAMC,WCFvBU,EAAQ,iD,4CAEd,sCAAAqD,EAAA,sDACQC,EAAO,GACTC,EAAoB,KAF1B,cAKQC,EAAc,cACdD,IACFC,GAAW,8BAA2BC,mBAAmBF,KAP/D,SAS2BG,MAAM1D,EAAQ,IAAMwD,GAT/C,cASUG,EATV,iBAUsBA,EAASC,OAV/B,WAUUC,EAVV,OAWUC,EAAUC,IAAEF,GAAKG,KAAK,kBAAkBC,UAAUtC,KAAI,SAACuC,GAAD,OAAUA,EAAKC,eAC3Eb,EAAKH,KAAL,MAAAG,EAAI,YAASQ,IAE6B,SAAtCC,IAAEF,GAAKG,KAAK,eAAeJ,OAdnC,qDAeIL,EAAoBQ,IAAEF,GAAKG,KAAK,yBAAyBJ,OAf7D,gDAiBSN,GAjBT,6C,0BA2Cec,E,YAtBb,WAAYrG,GAAQ,IAAD,8BACjB,4CAAMA,KAEDC,MAAQ,CACXsF,KAAM,MAJS,E,iFAQE,IAAD,Q,2CAClBe,GAAoBC,MAAK,SAAChB,GAAD,OAAU,EAAKlE,SAAS,CAAEkE,c,+BAKnD,IAAM5D,EAAgB,IAAI0C,gBAAgB/B,OAAOgC,SAASC,QAASiC,IAAI,UAEvE,OACE,kBAAC,EAAD,CAAUnE,UAAWhC,KAAKJ,MAAMsF,KAAMtD,MAAOA,EAAON,aAAcA,Q,GAlBtDL,IAAMC,WCtBxBkF,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,W","file":"static/js/main.54e00296.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/spinner.2f27f045.ico\";","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport './Audio.scss';\nimport spinner from './spinner.ico';\n\n// Enum.\nconst loading = 'loading';\nconst loaded = 'loaded';\n\nclass Audio extends React.Component {\n  static propTypes = {\n    url: PropTypes.string.isRequired,\n    isPlaying: PropTypes.bool.isRequired,\n    filename: PropTypes.string.isRequired,\n\n    onPlayPressed: PropTypes.func.isRequired,\n    onPausePressed: PropTypes.func.isRequired,\n    onEnded: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      loadingStatus: props.isPlaying ? loading : null,\n    }\n  }\n\n  render() {\n    const filenameClassName = this.props.isPlaying ? 'filename playing' : 'filename';\n\n    if (!this.props.isPlaying) {\n      return (\n        <div className='Audio' onClick={() => this.onPlayPressed()}>\n          <div className='play-pause-symbol-container' role=\"button\">\n            <span role=\"img\" className='play-symbol' aria-label=\"Play\">></span>\n          </div>\n\n          <div className={filenameClassName}>\n            {this.props.filename}\n          </div>\n        </div>\n      );\n    }\n\n    if (this.state.loadingStatus === loading) {\n      // The point of this <audio> element is just to load the file. It will actually be played by\n      // the <audio> element that is rendered in the other case of this function.\n      return (\n        <div className='Audio' onClick={() => this.onPausePressed()}>\n          <div className='loading-spinner-container' role=\"button\">\n            <img role=\"img\" src={spinner} className='spinner' alt='' aria-label=\"Play\"></img>\n\n            <audio autoPlay={true} onCanPlay={() => this.onLoadingFinished()}>\n              <source src={this.props.url}/>\n            </audio>\n          </div>\n\n          <div className={filenameClassName}>\n            {this.props.filename}\n          </div>\n        </div>\n      );\n    }\n\n    if (this.state.loadingStatus === loaded) {\n      return (\n        <div className='Audio' onClick={() => this.onPausePressed()}>\n          <div className='play-pause-symbol-container' role=\"button\">\n            <span role=\"img\" className='pause-symbol' aria-label=\"Pause\">|  |</span>\n            \n            <audio autoPlay={true} onEnded={() => this.props.onEnded()}>\n              <source src={this.props.url}/>\n            </audio>\n          </div>\n\n          <div className={filenameClassName}>\n            {this.props.filename}\n          </div>\n        </div>\n      );\n    }\n  }\n\n  onPlayPressed() {\n    this.props.onPlayPressed();\n  }\n\n  onLoadingFinished() {\n    this.setState({ loadingStatus: loaded });\n  }\n\n  onPausePressed() {\n    this.props.onPausePressed();\n  }\n}\n\nexport default Audio;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport _ from 'lodash';\n\nimport './SongList.scss';\n\nimport Audio from './Audio';\n\nclass SongList extends React.Component {\n  static propTypes = {\n    filenames: PropTypes.arrayOf(PropTypes.string.isRequired), // may be null if we haven't loaded the data yet.\n    s3Url: PropTypes.string.isRequired,\n\n    searchString: PropTypes.string, // Optional; what to initialize the searchString prop to.\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      // These pieces of state are for the search feature. The main challenge is that searching\n      // through all filenames is expensive, so we don't want to do it on every keystroke. Instead\n      // we want to do it when the user pauses typing. So while they're in the middle of typing,\n      // we'll have some text in the input box that we haven't actually done a search with yet. We\n      // need to represent this intermediate state, so we need to store 1) 'searchString', the thing\n      // to be searched, separately from 2) 'visibleFiles', the result of the search.\n      visibleFiles: props.filenames === null ? null : [],\n      searchString: props.searchString || '',\n      \n      currentlyPlaying: [], // a list of filename strings (many songs can be playing at once).\n    };\n  }\n\n  componentDidMount() {\n    // Allows use of the 'back' button to go between searches.\n    window.addEventListener('popstate', this.handleOnPopState);\n  }\n\n  componentWillUnmount() {\n    // Allows use of the 'back' button to go between searches.\n    window.removeEventListener('popstate', this.handleOnPopState);\n\n    // Cancel any doSearches that may be waiting to run.\n    if (this.currentTimeoutId) {\n      clearTimeout(this.currentTimeoutId);\n    }\n  }\n\n  handleOnPopState = (event) => {\n    let searchString = '';\n    if (event.state) {\n      searchString = event.state.searchString;\n    }\n\n    this.setState({ searchString, });\n    this.doSearch(searchString);\n  }\n\n  // If the available filenames change, we need to redo our search. \n  componentDidUpdate(prevProps, _prevState, _snapshot) {\n    if (_.isEqual(this.props.filenames, prevProps.filenames)) {\n      return;\n    }\n\n    this.doSearch(this.state.searchString);\n  }\n\n  render() {\n    const visibleFiles = this.state.visibleFiles;\n    const loadingIndicator = <span>Loading...</span>; // TODO: Make it cool.\n\n    return (\n      <div className='SongList'>\n        <input\n          placeholder=\"Search...\"\n          autoFocus={true}\n          value={this.state.searchString}\n          role={'searchbox'}\n          spellCheck=\"false\"\n          onFocus={(event) => event.target.select()}\n          onChange={(event) => this.onSearchTermChanged(event.target.value)}\n        />\n\n        <div style={{marginTop: '1rem'}}>\n          {(visibleFiles && visibleFiles.map(this.renderFile)) || loadingIndicator}\n        </div>\n      </div>\n    );\n  }\n\n  renderFile = (filename) => {\n    const isPlaying = this.state.currentlyPlaying.includes(filename);\n    // 'key' is necessary because we want to create a new component when the song is played, rather\n    // than updating the existing component instance. We want to do this because we need to reset\n    // state. See\n    // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key\n    // .\n    const key = `${filename}-${isPlaying}`;\n\n    return (\n      <div className='file-container' key={filename}>\n        <Audio\n          url={this.props.s3Url + filename}\n          isPlaying={isPlaying}\n          key={key}\n          filename={filename}\n\n          onPlayPressed={() => this.startPlaying(filename)}\n          onPausePressed={() => this.stopPlaying(filename)}\n          onEnded={() => this.onEnded(filename)}\n        />\n      </div>\n    );\n  }\n\n  onSearchTermChanged(string) {\n    this.setState({ searchString: string });\n\n    // Stop the previous search, if any, from happening; this new one supersedes it.\n    if (this.currentTimeoutId) {\n      clearTimeout(this.currentTimeoutId);\n    }\n\n    const delay = 750; // ms\n    this.currentTimeoutId = setTimeout(() => {\n      this.doSearch(string);\n      this.saveSearchString(string);\n    }, delay);\n  }\n\n  // Update 'visibleFiles.'\n  doSearch(searchString) {\n    const downcasedSearchString = searchString.toLowerCase();\n    // Display no files on an empty search.\n    if (downcasedSearchString === '') {\n      this.setState({ visibleFiles: [] });\n      return;\n    }\n    \n    const filtered = this.props.filenames.filter(\n      (filename) => filename.toLowerCase().includes(downcasedSearchString)\n    );\n    this.setState({ visibleFiles: filtered });\n  }\n\n  // Marks this search string as a 'checkpoint', saving it in the URL and enabling us to use the\n  // back button to come back to it later.\n  saveSearchString(string) {\n    const urlParams = new URLSearchParams(window.location.search);\n    urlParams.set('search', string);\n    \n    // See https://developer.mozilla.org/en-US/docs/Web/API/History/pushState . In particular: most\n    // browsers ignore the second argument so we pass the empty string.\n    window.history.pushState(\n      { searchString: string },\n      '',\n      window.location.origin + window.location.pathname + '?' + urlParams.toString()\n    );\n  }\n\n  onEnded(filename) {\n    const justEndedSongIndex = this.state.visibleFiles.indexOf(filename);\n    const nextUpSongIndex = justEndedSongIndex + 1;\n\n    let newCurrentlyPlaying = this.state.currentlyPlaying;\n    newCurrentlyPlaying = newCurrentlyPlaying.filter((f) => f !== filename); // stop this song\n\n    if (nextUpSongIndex < this.state.visibleFiles.length) {\n      const nextSong = this.state.visibleFiles[nextUpSongIndex];\n      newCurrentlyPlaying.push(nextSong);\n    } else {\n      // If we're at the end, do nothing.\n    }\n\n    this.setState({ currentlyPlaying: newCurrentlyPlaying });\n  }\n\n  startPlaying(filename) {\n    this.setState({ currentlyPlaying: this.state.currentlyPlaying.concat(filename) });\n  }\n\n  stopPlaying(filename) {\n    this.setState({ currentlyPlaying: this.state.currentlyPlaying.filter((f) => f !== filename) });\n  }\n}\n\nexport default SongList;\n","import React from 'react';\nimport $ from 'jquery'; // We use jQuery just in this file to parse XML.\n\nimport SongList from './SongList';\n\n// Globals.\nconst s3Url = 'https://elis-music.s3.us-east-2.amazonaws.com/';\n\nasync function getKeysInS3Bucket() {\n  const keys = [];\n  let continuationToken = null;\n\n  while (true) {\n    let paramString = 'list-type=2';\n    if (continuationToken) {\n      paramString += `&continuation-token=${encodeURIComponent(continuationToken)}`\n    }\n    const response = await fetch(s3Url + '?' + paramString);\n    const xml = await response.text();\n    const newkeys = $(xml).find(\"Contents > Key\").toArray().map((node) => node.textContent);\n    keys.push(...newkeys);\n\n    if ($(xml).find(\"IsTruncated\").text() !== 'true') { break; }\n    continuationToken = $(xml).find(\"NextContinuationToken\").text();\n  }\n  return keys;\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      keys: null, // list of strings; the keys we've loaded from S3. null if we haven't loaded them yet.\n    };\n  }\n\n  componentDidMount() {\n    getKeysInS3Bucket().then((keys) => this.setState({ keys }));\n  }\n\n  render() {\n    // Try to extract searchString from queryparams; if it's not present, the result will be null.\n    const searchString = (new URLSearchParams(window.location.search)).get('search');\n    \n    return (\n      <SongList filenames={this.state.keys} s3Url={s3Url} searchString={searchString}/>\n    )\n  }  \n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport App from './App.jsx';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}