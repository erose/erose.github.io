{"version":3,"sources":["play.svg","pause.svg","spinner.ico","audio-visualizer.jsx","Audio.jsx","SongList.jsx","App.jsx","index.jsx"],"names":["module","exports","AudioVisualizer","audioElement","this","audioContext","AudioContext","lowPassFilter","createBiquadFilter","type","highPassFilter","lowFreqAnalyser","createAnalyser","fftSize","highFreqAnalyser","source","createMediaElementSource","connect","destination","bufferLength","frequencyBinCount","lowFreqDataArray","Uint8Array","highFreqDataArray","getByteTimeDomainData","lowFreqMax","Math","max","x","min","exp","highFreqMax","y","z","Audio","props","onAudioElementRefAvailable","doVisualization","visualizer","currentAnimationId","requestAnimationFrame","draw","document","body","style","backgroundColor","getColor","state","loadingStatus","isPlaying","canvas","React","createRef","currentIntervalId","clearInterval","stopVisualization","filenameClassName","className","onClick","onPausePressed","role","src","spinner","alt","aria-label","autoPlay","crossOrigin","onCanPlay","onLoadingFinished","url","filename","pause","ref","onEnded","onPlayPressed","play","setState","cancelAnimationFrame","Component","SongList","handleOnPopState","event","searchString","doSearch","handleKeyDown","key","ctrlKeyDepressed","handleKeyUp","renderFile","currentlyPlaying","includes","s3Url","encodeURIComponent","partyMode","startPlaying","stopPlaying","target","rel","href","lyricsUrlFromFilename","visibleFiles","filenames","searchBoxRef","window","addEventListener","removeEventListener","currentTimeoutId","clearTimeout","prevProps","_prevState","_snapshot","_","isEqual","loadingIndicator","isMobile","test","navigator","userAgent","newSearchButton","onNewClicked","partyModeText","partyModeToggle","placeholder","autoFocus","value","spellCheck","onFocus","select","onChange","onSearchTermChanged","marginTop","map","current","splits","split","length","assumedArtistName","assumedSongName","replace","dasherize","s","punctuationRegex","string","setTimeout","saveSearchString","downcasedSearchString","toLowerCase","filtered","filter","urlParams","URLSearchParams","location","search","set","history","pushState","origin","pathname","toString","nextUpSongIndex","indexOf","newCurrentlyPlaying","f","nextSong","push","setDocumentTitle","concat","toDisplay","last","title","a","keys","continuationToken","paramString","fetch","response","text","xml","newkeys","$","find","toArray","node","textContent","App","getKeysInS3Bucket","then","get","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.ff067507.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/play.53d7188e.svg\";","module.exports = __webpack_public_path__ + \"static/media/pause.c7564688.svg\";","module.exports = __webpack_public_path__ + \"static/media/spinner.2f27f045.ico\";","export default class AudioVisualizer {\n  constructor(audioElement) {\n    this.audioContext = new AudioContext();\n\n    // TODO: Explain.\n    this.lowPassFilter = this.audioContext.createBiquadFilter();\n    this.lowPassFilter.type = 'lowpass';\n    this.highPassFilter = this.audioContext.createBiquadFilter();\n    this.highPassFilter.type = \"highpass\";\n    this.lowFreqAnalyser = this.audioContext.createAnalyser();\n    this.lowFreqAnalyser.fftSize = 2048;\n    this.highFreqAnalyser = this.audioContext.createAnalyser();\n    this.highFreqAnalyser.fftSize = 2048;\n\n    this.source = this.audioContext.createMediaElementSource(audioElement);\n    this.source.connect(this.lowPassFilter);\n    this.source.connect(this.highPassFilter);\n\n    this.lowPassFilter.connect(this.lowFreqAnalyser);\n    this.highPassFilter.connect(this.highFreqAnalyser);\n    this.source.connect(this.audioContext.destination);\n  }\n\n  // Returns a string suitable to be used as the value for CSS 'background-color' or 'color'\n  // attributes.\n  getColor() {\n    // TODO: Explain.\n    const bufferLength = this.lowFreqAnalyser.frequencyBinCount;\n    const lowFreqDataArray = new Uint8Array(bufferLength);\n    const highFreqDataArray = new Uint8Array(bufferLength);\n    this.lowFreqAnalyser.getByteTimeDomainData(lowFreqDataArray);\n    this.highFreqAnalyser.getByteTimeDomainData(highFreqDataArray);\n\n    const lowFreqMax = Math.max(...lowFreqDataArray);\n    const x = 128 + Math.min(Math.exp((lowFreqMax - 128) / 10.0), 128);\n    const highFreqMax = Math.max(...highFreqDataArray);\n    const y = 128 + Math.min(Math.exp((highFreqMax - 128) / 10.0), 128);\n    const z = (x + y) / 2;\n\n    return `rgb(${x}, ${y}, ${z})`;\n  }\n}\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport './Audio.scss';\nimport play from './play.svg';\nimport pause from './pause.svg';\nimport spinner from './spinner.ico';\n\nimport AudioVisualizer from './audio-visualizer';\n\n// Enum.\nconst loading = 'loading';\nconst loaded = 'loaded';\n\nclass Audio extends React.Component {\n  static propTypes = {\n    url: PropTypes.string.isRequired,\n    isPlaying: PropTypes.bool.isRequired,\n    filename: PropTypes.string.isRequired,\n    doVisualization: PropTypes.bool.isRequired,\n\n    onPlayPressed: PropTypes.func.isRequired,\n    onPausePressed: PropTypes.func.isRequired,\n    onEnded: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      loadingStatus: props.isPlaying ? loading : null,\n    }\n\n    this.audioElement = null; // TODO explain\n    this.canvas = React.createRef(); // TODO explain\n    this.currentAnimationId = null; // TODO explain\n  }\n\n  componentWillUnmount() {\n    // Cancel any getDataFromAnalyser calls that may be waiting to run.\n    if (this.currentIntervalId) {\n      clearInterval(this.currentIntervalId);\n    }\n\n    this.stopVisualization();\n  }\n\n  render() {\n    const filenameClassName = this.props.isPlaying ? 'filename playing' : 'filename';\n\n    if (!this.props.isPlaying) {\n      return (\n        <div className='Audio' onClick={() => this.onPlayPressed()}>\n          <div className='icon-container play-pause' role=\"button\">\n            <img src={play} className='play-symbol' alt='' aria-label=\"Play\"/>\n          </div>\n\n          <div className={filenameClassName}>\n            {this.props.filename}\n          </div>\n        </div>\n      );\n    }\n\n    if (this.state.loadingStatus === loading) {\n      // The point of this <audio> element is just to load the file. It will actually be played by\n      // the <audio> element that is rendered in the other case of this function.\n      return (\n        <div className='Audio' onClick={() => this.onPausePressed()}>\n          <div className='icon-container loading-spinner' role=\"button\">\n            <img src={spinner} className='spinner' alt='' aria-label=\"Play\"/>\n\n            <audio autoPlay={true} crossOrigin='anonymous' onCanPlay={() => this.onLoadingFinished()}>\n              <source src={this.props.url}/>\n            </audio>\n          </div>\n\n          <div className={filenameClassName}>\n            {this.props.filename}\n          </div>\n        </div>\n      );\n    }\n\n    if (this.state.loadingStatus === loaded) {\n      return (\n        <div className='Audio' onClick={() => this.onPausePressed()}>\n          <div className='icon-container play-pause' role=\"button\">\n            <img src={pause} className='pause-symbol' alt='' aria-label=\"Pause\"/>\n            \n            <audio ref={this.onAudioElementRefAvailable} crossOrigin='anonymous' autoPlay={true} onEnded={() => this.props.onEnded()}>\n              <source src={this.props.url}/>\n            </audio>\n          </div>\n\n          <div className={filenameClassName}>\n            {this.props.filename}\n          </div>\n        </div>\n      );\n    }\n  }\n\n  onAudioElementRefAvailable = (audioElement) => {\n    if (this.props.doVisualization && audioElement !== null) {\n      this.visualizer = new AudioVisualizer(audioElement);\n      this.currentAnimationId = requestAnimationFrame(this.draw);\n    }\n  }\n\n  draw = () => {\n    // Retrieve the color appropriate to this moment in the song, and set it.\n    document.body.style.backgroundColor = this.visualizer.getColor();\n\n    this.currentAnimationId = requestAnimationFrame(this.draw);\n  }\n\n  onPlayPressed() {\n    this.props.onPlayPressed();\n  }\n\n  onLoadingFinished() {\n    this.setState({ loadingStatus: loaded });\n  }\n\n  onPausePressed() {\n    this.stopVisualization();\n    this.props.onPausePressed();\n  }\n\n  stopVisualization() {\n    document.body.style.backgroundColor = '';\n    cancelAnimationFrame(this.currentAnimationId);\n    this.currentAnimationId = null;\n  }\n}\n\nexport default Audio;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport _ from 'lodash';\n\nimport './SongList.scss';\n\nimport Audio from './Audio';\n\nclass SongList extends React.Component {\n  static propTypes = {\n    filenames: PropTypes.arrayOf(PropTypes.string.isRequired), // may be null if we haven't loaded the data yet.\n    s3Url: PropTypes.string.isRequired,\n\n    searchString: PropTypes.string, // Optional; what to initialize the searchString prop to.\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      // These pieces of state are for the search feature. The main challenge is that searching\n      // through all filenames is expensive, so we don't want to do it on every keystroke. Instead\n      // we want to do it when the user pauses typing. So while they're in the middle of typing,\n      // we'll have some text in the input box that we haven't actually done a search with yet. We\n      // need to represent this intermediate state, so we need to store 1) 'searchString', the thing\n      // to be searched, separately from 2) 'visibleFiles', the result of the search.\n      visibleFiles: props.filenames === null ? null : [],\n      searchString: props.searchString || '',\n      \n      currentlyPlaying: [], // a list of filename strings (many songs can be playing at once).\n      ctrlKeyDepressed: false, // some extra behavior is enabled when this is true.\n      partyMode: false, // if on, do cool visualizations when the songs are played.\n    };\n\n    // We maintain a ref to the search box so we can have buttons that focus on it.\n    this.searchBoxRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // Allows use of the 'back' button to go between searches.\n    window.addEventListener('popstate', this.handleOnPopState);\n\n    // Allows us to track whether the ctrl key is pressed.\n    window.addEventListener('keydown', this.handleKeyDown);\n    window.addEventListener('keyup', this.handleKeyUp);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('popstate', this.handleOnPopState);\n    window.removeEventListener('keydown', this.handleKeyDown);\n    window.removeEventListener('keyup', this.handleKeyUp);\n\n    // Cancel any doSearches that may be waiting to run.\n    if (this.currentTimeoutId) {\n      clearTimeout(this.currentTimeoutId);\n    }\n  }\n\n  handleOnPopState = (event) => {\n    let searchString = '';\n    if (event.state) {\n      searchString = event.state.searchString;\n    }\n\n    this.setState({ searchString, });\n    this.doSearch(searchString);\n  }\n\n  handleKeyDown = (event) => {\n    if (event.key === 'Control') {\n      this.setState({ ctrlKeyDepressed: true });\n    }\n  }\n\n  handleKeyUp = (event) => {\n    if (event.key === 'Control') {\n      this.setState({ ctrlKeyDepressed: false }); \n    }\n  }\n\n  // If the available filenames change, we need to redo our search. \n  componentDidUpdate(prevProps, _prevState, _snapshot) {\n    if (_.isEqual(this.props.filenames, prevProps.filenames)) {\n      return;\n    }\n\n    this.doSearch(this.state.searchString);\n  }\n\n  render() {\n    const visibleFiles = this.state.visibleFiles;\n    const loadingIndicator = <span>Loading...</span>; // TODO: Make it cool.\n\n    // The goal here is to minimize the number of clicks a user has to make between loading the page\n    // and typing in a song name. On desktop, we autofocus so this number is 0. On mobile,\n    // autofocusing will not bring up the keyboard unless it happens as part of a user action, so we\n    // provide this \"new search\" button.\n\n     // This sniffing might be unreliable, but seems good enough given that the users are just me.\n    const isMobile = /Mobi|Android/i.test(navigator.userAgent);\n    const newSearchButton = (\n      <button onClick={() => this.onNewClicked()}>\n        New Search\n      </button>\n    );\n\n    const partyModeText = this.state.partyMode ? 'ON' : 'OFF';\n    const partyModeToggle = (\n      <span className=\"party-mode-toggle\">\n        Party mode\n        <button className=\"party-mode-toggle-button\" onClick={() => this.setState({ partyMode: !this.state.partyMode })}>{partyModeText}</button>\n      </span>\n    );\n\n    return (\n      <div className='SongList'>\n        <div className='header'>\n          <input\n            placeholder=\"Search...\"\n            autoFocus={true}\n            value={this.state.searchString}\n            role={'searchbox'}\n            spellCheck=\"false\"\n            className=\"search-box\"\n            ref={this.searchBoxRef}\n            onFocus={(event) => event.target.select()}\n            onChange={(event) => this.onSearchTermChanged(event.target.value)}\n          />\n\n          {isMobile ? newSearchButton : null}\n          {partyModeToggle}\n        </div>\n\n        <div style={{marginTop: '1rem'}}>\n          {(visibleFiles && visibleFiles.map(this.renderFile)) || loadingIndicator}\n        </div>\n      </div>\n    );\n  }\n\n  onNewClicked() {\n    // See render for explanation.\n    this.searchBoxRef.current.select();\n  }\n\n  renderFile = (filename) => {\n    const isPlaying = this.state.currentlyPlaying.includes(filename);\n    // 'key' is necessary because we want to create a new component when the song is played, rather\n    // than updating the existing component instance. We want to do this because we need to reset\n    // state. See\n    // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key\n    // .\n    const key = `${filename}-${isPlaying}`;\n    const url = this.props.s3Url + encodeURIComponent(filename);\n\n    return (\n      <div className='file-container' key={filename}>\n        <Audio\n          url={url}\n          isPlaying={isPlaying}\n          key={key}\n          filename={filename}\n          doVisualization={this.state.partyMode}\n\n          onPlayPressed={() => this.startPlaying(filename)}\n          onPausePressed={() => this.stopPlaying(filename)}\n          onEnded={() => this.onEnded(filename)}\n        />\n\n        <a className='lyrics-link' target='_blank' rel='noopener noreferrer' href={this.lyricsUrlFromFilename(filename)}>Lyrics</a>\n        <a className='download-link' href={url}>Download (right click)</a>\n      </div>\n    );\n  }\n\n  /**\n   * @return {string, null} Null if the lyrics URL could not be constructed, for instance if the\n   *     filename doesn't seem to contain both an artist name and a song name.\n   */\n  lyricsUrlFromFilename(filename) {\n    const splits = filename.split('/');\n    if (splits.length < 2) {\n      return null;\n    }\n\n    let assumedArtistName = splits[0];\n    let assumedSongName = splits[splits.length - 1].replace(/\\d+( -)? /g, ''); // get rid of the track number\n\n    // Get rid of '.mp3'\n    assumedSongName = assumedSongName.replace(/\\.mp3/, '');\n\n    const dasherize = (s) => s.replace(/ +/g, '-');\n    assumedArtistName = dasherize(assumedArtistName);\n    assumedSongName = dasherize(assumedSongName);\n\n    // Genius seems to strip out exclamation points. I'm guessing it strips out other punctuation as\n    // well.\n    const punctuationRegex = /[(!?.)]/g;\n    assumedArtistName = assumedArtistName.replace(punctuationRegex, '');\n    assumedSongName = assumedSongName.replace(punctuationRegex, '');\n\n    return `https://genius.com/${assumedArtistName}-${assumedSongName}-lyrics`;\n  }\n\n  onSearchTermChanged(string) {\n    this.setState({ searchString: string });\n\n    // Stop the previous search, if any, from happening; this new one supersedes it.\n    if (this.currentTimeoutId) {\n      clearTimeout(this.currentTimeoutId);\n    }\n\n    const delay = 750; // ms\n    this.currentTimeoutId = setTimeout(() => {\n      this.doSearch(string);\n      this.saveSearchString(string);\n    }, delay);\n  }\n\n  // Update 'visibleFiles.'\n  doSearch(searchString) {\n    const downcasedSearchString = searchString.toLowerCase();\n    // Display no files on an empty search.\n    if (downcasedSearchString === '') {\n      this.setState({ visibleFiles: [] });\n      return;\n    }\n    \n    const filtered = this.props.filenames.filter(\n      (filename) => filename.toLowerCase().includes(downcasedSearchString)\n    );\n    this.setState({ visibleFiles: filtered });\n  }\n\n  // Marks this search string as a 'checkpoint', saving it in the URL and enabling us to use the\n  // back button to come back to it later.\n  saveSearchString(string) {\n    const urlParams = new URLSearchParams(window.location.search);\n    urlParams.set('search', string);\n    \n    // See https://developer.mozilla.org/en-US/docs/Web/API/History/pushState . In particular: most\n    // browsers ignore the second argument so we pass the empty string.\n    window.history.pushState(\n      { searchString: string },\n      '',\n      window.location.origin + window.location.pathname + '?' + urlParams.toString()\n    );\n  }\n\n  onEnded(filename) {\n    const justEndedSongIndex = this.state.visibleFiles.indexOf(filename);\n    const nextUpSongIndex = justEndedSongIndex + 1;\n\n    let newCurrentlyPlaying = this.state.currentlyPlaying;\n    newCurrentlyPlaying = newCurrentlyPlaying.filter((f) => f !== filename); // stop this song\n\n    if (nextUpSongIndex < this.state.visibleFiles.length) {\n      const nextSong = this.state.visibleFiles[nextUpSongIndex];\n      newCurrentlyPlaying.push(nextSong);\n    } else {\n      // If we're at the end, do nothing.\n    }\n\n    this.setState({ currentlyPlaying: newCurrentlyPlaying }, () => this.setDocumentTitle());\n  }\n\n  startPlaying(filename) {\n    // We allow the user to play multiple songs at the same time if they hold down the control key\n    // when clicking on a new song to be played.\n    let newCurrentlyPlaying;\n    if (this.state.ctrlKeyDepressed) {\n      newCurrentlyPlaying = this.state.currentlyPlaying.concat([filename]);\n    } else {\n      newCurrentlyPlaying = [filename];\n    }\n\n    this.setState({ currentlyPlaying: newCurrentlyPlaying }, () => this.setDocumentTitle());\n  }\n\n  stopPlaying(filename) {\n    this.setState(\n      { currentlyPlaying: this.state.currentlyPlaying.filter((f) => f !== filename) },\n      () => this.setDocumentTitle()\n    );\n  }\n\n  setDocumentTitle() {\n    const filename = this.state.currentlyPlaying[0];\n    // We just want to show the base part of the filename — not the artist or album.\n    const toDisplay = filename && _.last(filename.split('/'));\n\n    if (toDisplay) {\n      document.title = `🎶 — ${toDisplay}`;\n    } else {\n      document.title = `🎶`;\n    }\n  }\n}\n\nexport default SongList;\n","import React from 'react';\nimport $ from 'jquery'; // We use jQuery just in this file to parse XML.\n\nimport SongList from './SongList';\n\n// Globals.\nconst s3Url = 'https://elis-music.s3.us-east-2.amazonaws.com/';\n\nasync function getKeysInS3Bucket() {\n  const keys = [];\n  let continuationToken = null;\n\n  while (true) {\n    let paramString = 'list-type=2';\n    if (continuationToken) {\n      paramString += `&continuation-token=${encodeURIComponent(continuationToken)}`\n    }\n    const response = await fetch(s3Url + '?' + paramString);\n    const xml = await response.text();\n    const newkeys = $(xml).find(\"Contents > Key\").toArray().map((node) => node.textContent);\n    keys.push(...newkeys);\n\n    if ($(xml).find(\"IsTruncated\").text() !== 'true') { break; }\n    continuationToken = $(xml).find(\"NextContinuationToken\").text();\n  }\n  return keys;\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      keys: null, // list of strings; the keys we've loaded from S3. null if we haven't loaded them yet.\n    };\n  }\n\n  componentDidMount() {\n    getKeysInS3Bucket().then((keys) => this.setState({ keys }));\n  }\n\n  render() {\n    // Try to extract searchString from queryparams; if it's not present, the result will be null.\n    const searchString = (new URLSearchParams(window.location.search)).get('search');\n    \n    return (\n      <SongList filenames={this.state.keys} s3Url={s3Url} searchString={searchString}/>\n    )\n  }  \n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport App from './App.jsx';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}