{"version":3,"sources":["spinner.ico","Audio.jsx","SongList.jsx","App.jsx","index.jsx"],"names":["module","exports","Audio","props","state","loadingStatus","isPlaying","filenameClassName","this","className","onClick","onPausePressed","role","src","spinner","alt","aria-label","autoPlay","onCanPlay","onLoadingFinished","url","filename","onEnded","onPlayPressed","setState","React","Component","SongList","handleOnPopState","event","searchString","doSearch","renderFile","currentlyPlaying","includes","key","s3Url","startPlaying","stopPlaying","visibleFiles","filenames","searchBoxRef","createRef","window","addEventListener","removeEventListener","currentTimeoutId","clearTimeout","prevProps","_prevState","_snapshot","_","isEqual","loadingIndicator","placeholder","autoFocus","value","spellCheck","ref","onFocus","target","select","onChange","onSearchTermChanged","onNewClicked","style","marginTop","map","current","string","setTimeout","saveSearchString","downcasedSearchString","toLowerCase","filtered","filter","urlParams","URLSearchParams","location","search","set","history","pushState","origin","pathname","toString","nextUpSongIndex","indexOf","newCurrentlyPlaying","f","length","nextSong","push","setDocumentTitle","concat","toDisplay","last","split","document","title","a","keys","continuationToken","paramString","encodeURIComponent","fetch","response","text","xml","newkeys","$","find","toArray","node","textContent","App","getKeysInS3Bucket","then","get","ReactDOM","render","getElementById"],"mappings":"sGAAAA,EAAOC,QAAU,IAA0B,qC,yTCkG5BC,E,YA7Eb,WAAYC,GAAQ,IAAD,8BACjB,4CAAMA,KAEDC,MAAQ,CACXC,cAAeF,EAAMG,UAlBX,UAkBiC,MAJ5B,E,sEAQT,IAAD,OACDC,EAAoBC,KAAKL,MAAMG,UAAY,mBAAqB,WAEtE,OAAKE,KAAKL,MAAMG,UAzBJ,YAuCRE,KAAKJ,MAAMC,cAIX,yBAAKI,UAAU,QAAQC,QAAS,kBAAM,EAAKC,mBACzC,yBAAKF,UAAU,iCAAiCG,KAAK,UACnD,yBAAKA,KAAK,MAAMC,IAAKC,IAASL,UAAU,UAAUM,IAAI,GAAGC,aAAW,SAEpE,2BAAOC,UAAU,EAAMC,UAAW,kBAAM,EAAKC,sBAC3C,4BAAQN,IAAKL,KAAKL,MAAMiB,QAI5B,yBAAKX,UAAWF,GACbC,KAAKL,MAAMkB,WApDT,WA0DPb,KAAKJ,MAAMC,cAEX,yBAAKI,UAAU,QAAQC,QAAS,kBAAM,EAAKC,mBACzC,yBAAKF,UAAU,4BAA4BG,KAAK,UAC9C,0BAAMA,KAAK,MAAMH,UAAU,eAAeO,aAAW,SAArD,QAEA,2BAAOC,UAAU,EAAMK,QAAS,kBAAM,EAAKnB,MAAMmB,YAC/C,4BAAQT,IAAKL,KAAKL,MAAMiB,QAI5B,yBAAKX,UAAWF,GACbC,KAAKL,MAAMkB,gBAZpB,EAhCI,yBAAKZ,UAAU,QAAQC,QAAS,kBAAM,EAAKa,kBACzC,yBAAKd,UAAU,4BAA4BG,KAAK,UAC9C,0BAAMA,KAAK,MAAMH,UAAU,cAAcO,aAAW,QAApD,MAGF,yBAAKP,UAAWF,GACbC,KAAKL,MAAMkB,a,sCA8CpBb,KAAKL,MAAMoB,kB,0CAIXf,KAAKgB,SAAS,CAAEnB,cAlFL,a,uCAsFXG,KAAKL,MAAMQ,qB,GApFKc,IAAMC,WCgNXC,E,YA1Mb,WAAYxB,GAAQ,IAAD,8BACjB,4CAAMA,KAkCRyB,iBAAmB,SAACC,GAClB,IAAIC,EAAe,GACfD,EAAMzB,QACR0B,EAAeD,EAAMzB,MAAM0B,cAG7B,EAAKN,SAAS,CAAEM,iBAChB,EAAKC,SAASD,IA1CG,EAwFnBE,WAAa,SAACX,GACZ,IAAMf,EAAY,EAAKF,MAAM6B,iBAAiBC,SAASb,GAMjDc,EAAG,UAAMd,EAAN,YAAkBf,GAE3B,OACE,yBAAKG,UAAU,iBAAiB0B,IAAKd,GACnC,kBAAC,EAAD,CACED,IAAK,EAAKjB,MAAMiC,MAAQf,EACxBf,UAAWA,EACX6B,IAAKA,EACLd,SAAUA,EAEVE,cAAe,kBAAM,EAAKc,aAAahB,IACvCV,eAAgB,kBAAM,EAAK2B,YAAYjB,IACvCC,QAAS,kBAAM,EAAKA,QAAQD,QAxGlC,EAAKjB,MAAQ,CAOXmC,aAAkC,OAApBpC,EAAMqC,UAAqB,KAAO,GAChDV,aAAc3B,EAAM2B,cAAgB,GAEpCG,iBAAkB,IAIpB,EAAKQ,aAAehB,IAAMiB,YAjBT,E,iFAsBjBC,OAAOC,iBAAiB,WAAYpC,KAAKoB,oB,6CAKzCe,OAAOE,oBAAoB,WAAYrC,KAAKoB,kBAGxCpB,KAAKsC,kBACPC,aAAavC,KAAKsC,oB,yCAeHE,EAAWC,EAAYC,GACpCC,IAAEC,QAAQ5C,KAAKL,MAAMqC,UAAWQ,EAAUR,YAI9ChC,KAAKuB,SAASvB,KAAKJ,MAAM0B,gB,+BAGjB,IAAD,OACDS,EAAe/B,KAAKJ,MAAMmC,aAC1Bc,EAAmB,4CAEzB,OACE,yBAAK5C,UAAU,YACb,6BACE,2BACE6C,YAAY,YACZC,WAAW,EACXC,MAAOhD,KAAKJ,MAAM0B,aAClBlB,KAAM,YACN6C,WAAW,QACXC,IAAKlD,KAAKiC,aACVkB,QAAS,SAAC9B,GAAD,OAAWA,EAAM+B,OAAOC,UACjCC,SAAU,SAACjC,GAAD,OAAW,EAAKkC,oBAAoBlC,EAAM+B,OAAOJ,UAG7D,4BAAQ9C,QAAS,kBAAM,EAAKsD,iBAA5B,eAKF,yBAAKC,MAAO,CAACC,UAAW,SACpB3B,GAAgBA,EAAa4B,IAAI3D,KAAKwB,aAAgBqB,M,qCAO9D7C,KAAKiC,aAAa2B,QAAQP,W,0CA4BRQ,GAAS,IAAD,OAC1B7D,KAAKgB,SAAS,CAAEM,aAAcuC,IAG1B7D,KAAKsC,kBACPC,aAAavC,KAAKsC,kBAIpBtC,KAAKsC,iBAAmBwB,YAAW,WACjC,EAAKvC,SAASsC,GACd,EAAKE,iBAAiBF,KAHV,O,+BAQPvC,GACP,IAAM0C,EAAwB1C,EAAa2C,cAE3C,GAA8B,KAA1BD,EAAJ,CAKA,IAAME,EAAWlE,KAAKL,MAAMqC,UAAUmC,QACpC,SAACtD,GAAD,OAAcA,EAASoD,cAAcvC,SAASsC,MAEhDhE,KAAKgB,SAAS,CAAEe,aAAcmC,SAP5BlE,KAAKgB,SAAS,CAAEe,aAAc,O,uCAYjB8B,GACf,IAAMO,EAAY,IAAIC,gBAAgBlC,OAAOmC,SAASC,QACtDH,EAAUI,IAAI,SAAUX,GAIxB1B,OAAOsC,QAAQC,UACb,CAAEpD,aAAcuC,GAChB,GACA1B,OAAOmC,SAASK,OAASxC,OAAOmC,SAASM,SAAW,IAAMR,EAAUS,c,8BAIhEhE,GAAW,IAAD,OAEViE,EADqB9E,KAAKJ,MAAMmC,aAAagD,QAAQlE,GACd,EAEzCmE,EAAsBhF,KAAKJ,MAAM6B,iBAGrC,GAFAuD,EAAsBA,EAAoBb,QAAO,SAACc,GAAD,OAAOA,IAAMpE,KAE1DiE,EAAkB9E,KAAKJ,MAAMmC,aAAamD,OAAQ,CACpD,IAAMC,EAAWnF,KAAKJ,MAAMmC,aAAa+C,GACzCE,EAAoBI,KAAKD,GAK3BnF,KAAKgB,SAAS,CAAES,iBAAkBuD,IAAuB,kBAAM,EAAKK,wB,mCAGzDxE,GAAW,IAAD,OACrBb,KAAKgB,SACH,CAAES,iBAAkBzB,KAAKJ,MAAM6B,iBAAiB6D,OAAOzE,KACvD,kBAAM,EAAKwE,wB,kCAIHxE,GAAW,IAAD,OACpBb,KAAKgB,SACH,CAAES,iBAAkBzB,KAAKJ,MAAM6B,iBAAiB0C,QAAO,SAACc,GAAD,OAAOA,IAAMpE,OACpE,kBAAM,EAAKwE,wB,yCAKb,IAAMxE,EAAWb,KAAKJ,MAAM6B,iBAAiB,GAEvC8D,EAAY1E,GAAY8B,IAAE6C,KAAK3E,EAAS4E,MAAM,MAGlDC,SAASC,MADPJ,EACF,8BAAyBA,GAEzB,mB,GA7MiBtE,IAAMC,WCFvBU,EAAQ,iD,4CAEd,sCAAAgE,EAAA,sDACQC,EAAO,GACTC,EAAoB,KAF1B,cAKQC,EAAc,cACdD,IACFC,GAAW,8BAA2BC,mBAAmBF,KAP/D,SAS2BG,MAAMrE,EAAQ,IAAMmE,GAT/C,cASUG,EATV,iBAUsBA,EAASC,OAV/B,WAUUC,EAVV,OAWUC,EAAUC,IAAEF,GAAKG,KAAK,kBAAkBC,UAAU7C,KAAI,SAAC8C,GAAD,OAAUA,EAAKC,eAC3Eb,EAAKT,KAAL,MAAAS,EAAI,YAASQ,IAE6B,SAAtCC,IAAEF,GAAKG,KAAK,eAAeJ,OAdnC,qDAeIL,EAAoBQ,IAAEF,GAAKG,KAAK,yBAAyBJ,OAf7D,gDAiBSN,GAjBT,6C,0BA2Cec,E,YAtBb,WAAYhH,GAAQ,IAAD,8BACjB,4CAAMA,KAEDC,MAAQ,CACXiG,KAAM,MAJS,E,iFAQE,IAAD,Q,2CAClBe,GAAoBC,MAAK,SAAChB,GAAD,OAAU,EAAK7E,SAAS,CAAE6E,c,+BAKnD,IAAMvE,EAAgB,IAAI+C,gBAAgBlC,OAAOmC,SAASC,QAASuC,IAAI,UAEvE,OACE,kBAAC,EAAD,CAAU9E,UAAWhC,KAAKJ,MAAMiG,KAAMjE,MAAOA,EAAON,aAAcA,Q,GAlBtDL,IAAMC,WCtBxB6F,IAASC,OAAO,kBAAC,EAAD,MAAStB,SAASuB,eAAe,W","file":"static/js/main.78c99280.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/spinner.2f27f045.ico\";","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport './Audio.scss';\nimport spinner from './spinner.ico';\n\n// Enum.\nconst loading = 'loading';\nconst loaded = 'loaded';\n\nclass Audio extends React.Component {\n  static propTypes = {\n    url: PropTypes.string.isRequired,\n    isPlaying: PropTypes.bool.isRequired,\n    filename: PropTypes.string.isRequired,\n\n    onPlayPressed: PropTypes.func.isRequired,\n    onPausePressed: PropTypes.func.isRequired,\n    onEnded: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      loadingStatus: props.isPlaying ? loading : null,\n    }\n  }\n\n  render() {\n    const filenameClassName = this.props.isPlaying ? 'filename playing' : 'filename';\n\n    if (!this.props.isPlaying) {\n      return (\n        <div className='Audio' onClick={() => this.onPlayPressed()}>\n          <div className='icon-container play-pause' role=\"button\">\n            <span role=\"img\" className='play-symbol' aria-label=\"Play\">></span>\n          </div>\n\n          <div className={filenameClassName}>\n            {this.props.filename}\n          </div>\n        </div>\n      );\n    }\n\n    if (this.state.loadingStatus === loading) {\n      // The point of this <audio> element is just to load the file. It will actually be played by\n      // the <audio> element that is rendered in the other case of this function.\n      return (\n        <div className='Audio' onClick={() => this.onPausePressed()}>\n          <div className='icon-container loading-spinner' role=\"button\">\n            <img role=\"img\" src={spinner} className='spinner' alt='' aria-label=\"Play\"></img>\n\n            <audio autoPlay={true} onCanPlay={() => this.onLoadingFinished()}>\n              <source src={this.props.url}/>\n            </audio>\n          </div>\n\n          <div className={filenameClassName}>\n            {this.props.filename}\n          </div>\n        </div>\n      );\n    }\n\n    if (this.state.loadingStatus === loaded) {\n      return (\n        <div className='Audio' onClick={() => this.onPausePressed()}>\n          <div className='icon-container play-pause' role=\"button\">\n            <span role=\"img\" className='pause-symbol' aria-label=\"Pause\">|  |</span>\n            \n            <audio autoPlay={true} onEnded={() => this.props.onEnded()}>\n              <source src={this.props.url}/>\n            </audio>\n          </div>\n\n          <div className={filenameClassName}>\n            {this.props.filename}\n          </div>\n        </div>\n      );\n    }\n  }\n\n  onPlayPressed() {\n    this.props.onPlayPressed();\n  }\n\n  onLoadingFinished() {\n    this.setState({ loadingStatus: loaded });\n  }\n\n  onPausePressed() {\n    this.props.onPausePressed();\n  }\n}\n\nexport default Audio;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport _ from 'lodash';\n\nimport './SongList.scss';\n\nimport Audio from './Audio';\n\nclass SongList extends React.Component {\n  static propTypes = {\n    filenames: PropTypes.arrayOf(PropTypes.string.isRequired), // may be null if we haven't loaded the data yet.\n    s3Url: PropTypes.string.isRequired,\n\n    searchString: PropTypes.string, // Optional; what to initialize the searchString prop to.\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      // These pieces of state are for the search feature. The main challenge is that searching\n      // through all filenames is expensive, so we don't want to do it on every keystroke. Instead\n      // we want to do it when the user pauses typing. So while they're in the middle of typing,\n      // we'll have some text in the input box that we haven't actually done a search with yet. We\n      // need to represent this intermediate state, so we need to store 1) 'searchString', the thing\n      // to be searched, separately from 2) 'visibleFiles', the result of the search.\n      visibleFiles: props.filenames === null ? null : [],\n      searchString: props.searchString || '',\n      \n      currentlyPlaying: [], // a list of filename strings (many songs can be playing at once).\n    };\n\n    // We maintain a ref to the search box so we can have buttons that focus on it.\n    this.searchBoxRef = React.createRef();\n  }\n\n  componentDidMount() {\n    // Allows use of the 'back' button to go between searches.\n    window.addEventListener('popstate', this.handleOnPopState);\n  }\n\n  componentWillUnmount() {\n    // Allows use of the 'back' button to go between searches.\n    window.removeEventListener('popstate', this.handleOnPopState);\n\n    // Cancel any doSearches that may be waiting to run.\n    if (this.currentTimeoutId) {\n      clearTimeout(this.currentTimeoutId);\n    }\n  }\n\n  handleOnPopState = (event) => {\n    let searchString = '';\n    if (event.state) {\n      searchString = event.state.searchString;\n    }\n\n    this.setState({ searchString, });\n    this.doSearch(searchString);\n  }\n\n  // If the available filenames change, we need to redo our search. \n  componentDidUpdate(prevProps, _prevState, _snapshot) {\n    if (_.isEqual(this.props.filenames, prevProps.filenames)) {\n      return;\n    }\n\n    this.doSearch(this.state.searchString);\n  }\n\n  render() {\n    const visibleFiles = this.state.visibleFiles;\n    const loadingIndicator = <span>Loading...</span>; // TODO: Make it cool.\n\n    return (\n      <div className='SongList'>\n        <div>\n          <input\n            placeholder=\"Search...\"\n            autoFocus={true}\n            value={this.state.searchString}\n            role={'searchbox'}\n            spellCheck=\"false\"\n            ref={this.searchBoxRef}\n            onFocus={(event) => event.target.select()}\n            onChange={(event) => this.onSearchTermChanged(event.target.value)}\n          />\n\n          <button onClick={() => this.onNewClicked()}>\n            New Search\n          </button>\n        </div>\n\n        <div style={{marginTop: '1rem'}}>\n          {(visibleFiles && visibleFiles.map(this.renderFile)) || loadingIndicator}\n        </div>\n      </div>\n    );\n  }\n\n  onNewClicked() {\n    this.searchBoxRef.current.select();\n  }\n\n  renderFile = (filename) => {\n    const isPlaying = this.state.currentlyPlaying.includes(filename);\n    // 'key' is necessary because we want to create a new component when the song is played, rather\n    // than updating the existing component instance. We want to do this because we need to reset\n    // state. See\n    // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key\n    // .\n    const key = `${filename}-${isPlaying}`;\n\n    return (\n      <div className='file-container' key={filename}>\n        <Audio\n          url={this.props.s3Url + filename}\n          isPlaying={isPlaying}\n          key={key}\n          filename={filename}\n\n          onPlayPressed={() => this.startPlaying(filename)}\n          onPausePressed={() => this.stopPlaying(filename)}\n          onEnded={() => this.onEnded(filename)}\n        />\n      </div>\n    );\n  }\n\n  onSearchTermChanged(string) {\n    this.setState({ searchString: string });\n\n    // Stop the previous search, if any, from happening; this new one supersedes it.\n    if (this.currentTimeoutId) {\n      clearTimeout(this.currentTimeoutId);\n    }\n\n    const delay = 750; // ms\n    this.currentTimeoutId = setTimeout(() => {\n      this.doSearch(string);\n      this.saveSearchString(string);\n    }, delay);\n  }\n\n  // Update 'visibleFiles.'\n  doSearch(searchString) {\n    const downcasedSearchString = searchString.toLowerCase();\n    // Display no files on an empty search.\n    if (downcasedSearchString === '') {\n      this.setState({ visibleFiles: [] });\n      return;\n    }\n    \n    const filtered = this.props.filenames.filter(\n      (filename) => filename.toLowerCase().includes(downcasedSearchString)\n    );\n    this.setState({ visibleFiles: filtered });\n  }\n\n  // Marks this search string as a 'checkpoint', saving it in the URL and enabling us to use the\n  // back button to come back to it later.\n  saveSearchString(string) {\n    const urlParams = new URLSearchParams(window.location.search);\n    urlParams.set('search', string);\n    \n    // See https://developer.mozilla.org/en-US/docs/Web/API/History/pushState . In particular: most\n    // browsers ignore the second argument so we pass the empty string.\n    window.history.pushState(\n      { searchString: string },\n      '',\n      window.location.origin + window.location.pathname + '?' + urlParams.toString()\n    );\n  }\n\n  onEnded(filename) {\n    const justEndedSongIndex = this.state.visibleFiles.indexOf(filename);\n    const nextUpSongIndex = justEndedSongIndex + 1;\n\n    let newCurrentlyPlaying = this.state.currentlyPlaying;\n    newCurrentlyPlaying = newCurrentlyPlaying.filter((f) => f !== filename); // stop this song\n\n    if (nextUpSongIndex < this.state.visibleFiles.length) {\n      const nextSong = this.state.visibleFiles[nextUpSongIndex];\n      newCurrentlyPlaying.push(nextSong);\n    } else {\n      // If we're at the end, do nothing.\n    }\n\n    this.setState({ currentlyPlaying: newCurrentlyPlaying }, () => this.setDocumentTitle());\n  }\n\n  startPlaying(filename) {\n    this.setState(\n      { currentlyPlaying: this.state.currentlyPlaying.concat(filename) },\n      () => this.setDocumentTitle()\n    );\n  }\n\n  stopPlaying(filename) {\n    this.setState(\n      { currentlyPlaying: this.state.currentlyPlaying.filter((f) => f !== filename) },\n      () => this.setDocumentTitle()\n    );\n  }\n\n  setDocumentTitle() {\n    const filename = this.state.currentlyPlaying[0];\n    // We just want to show the base part of the filename — not the artist or album.\n    const toDisplay = filename && _.last(filename.split('/'));\n\n    if (toDisplay) {\n      document.title = `🎶 — ${toDisplay}`;\n    } else {\n      document.title = `🎶`;\n    }\n  }\n}\n\nexport default SongList;\n","import React from 'react';\nimport $ from 'jquery'; // We use jQuery just in this file to parse XML.\n\nimport SongList from './SongList';\n\n// Globals.\nconst s3Url = 'https://elis-music.s3.us-east-2.amazonaws.com/';\n\nasync function getKeysInS3Bucket() {\n  const keys = [];\n  let continuationToken = null;\n\n  while (true) {\n    let paramString = 'list-type=2';\n    if (continuationToken) {\n      paramString += `&continuation-token=${encodeURIComponent(continuationToken)}`\n    }\n    const response = await fetch(s3Url + '?' + paramString);\n    const xml = await response.text();\n    const newkeys = $(xml).find(\"Contents > Key\").toArray().map((node) => node.textContent);\n    keys.push(...newkeys);\n\n    if ($(xml).find(\"IsTruncated\").text() !== 'true') { break; }\n    continuationToken = $(xml).find(\"NextContinuationToken\").text();\n  }\n  return keys;\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      keys: null, // list of strings; the keys we've loaded from S3. null if we haven't loaded them yet.\n    };\n  }\n\n  componentDidMount() {\n    getKeysInS3Bucket().then((keys) => this.setState({ keys }));\n  }\n\n  render() {\n    // Try to extract searchString from queryparams; if it's not present, the result will be null.\n    const searchString = (new URLSearchParams(window.location.search)).get('search');\n    \n    return (\n      <SongList filenames={this.state.keys} s3Url={s3Url} searchString={searchString}/>\n    )\n  }  \n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport App from './App.jsx';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}